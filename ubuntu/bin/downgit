#!/usr/bin/env bash

tmp="/tmp/.downgit"
mkdir -p "$tmp"
tmp_file="$tmp/api.json"
touch "$tmp_file"

cleanup() {
  rm -rf "$tmp"
}
trap cleanup SIGINT SIGTERM EXIT

display_usage() {
  cat <<EOF
downgit
A bash script to download the latest version of package from GitHub.

DEPENDENCIES
  fzf, jq, httpie

USAGE
  downgit [-h] [-r <release_query>] [-d <target_bin_dir>] [-e <executable_query>] [-n <binary_name>] <repo>

  -h Show this help message.
  -r Release query in FZF format. (e.g. '^fd x86_64 musl tar.gz$')
  -e Executable query in FZF format. (e.g. '/fd$')
  -n Binary name. (e.g. 'fd')
  -d Target bin directory. (e.g. \$HOME/bin)
EOF
}

while test $# -gt 0; do
  case "$1" in
   -h)
    display_usage
    exit 1
    ;;
   -r)
    shift
    release_query="$1"
    shift
    ;;
  -d)
    shift
    target_bin_dir="$1"
    shift
    ;;
  -e)
    shift
    executable_query="$1"
    shift
    ;;
  -n)
    shift
    name="$1"
    shift
    ;;
  *)
    break
    ;;
  esac
done

repo="$1"
if ! [ "$target_bin_dir" != "${2#/}" ]; then
  echo "target_bin_dir must be an absolute path"
  exit 1
fi

echo "[INFO] REPO: $repo"
echo "[INFO] RELEASE QUERY: $release_query"
echo "[INFO] TARGET_BIN_DIR: $target_bin_dir"
echo "[INFO] EXECUTABLE QUERY: $executable_query"
echo "[INFO] NAME: $name"
printf "\n"

url="https://api.github.com/repos/$repo/releases/latest"

if http --check-status --ignore-stdin --timeout=5 GET "$url" >"$tmp_file" 2>&1; then
  pushd "$tmp" >/dev/null || exit 1
  echo "Downloading latest release of $repo"

  release_name=$(
    jq -r '.assets[].name' "$tmp_file" |
      fzf \
        --query "$release_query" \
        --select-1 \
        --height=50% \
        --reverse \
        --no-info \
        --prompt="Select a release: " \
        --preview-window="hidden"
  )

  if [[ -z "$release_name" ]]; then
    echo "No release selected"
    exit
  fi

  browser_download_url=$(
    jq -r \
      --arg release_name "$release_name" '.assets[] | select(.name == $release_name) | .browser_download_url' \
      "$tmp_file"
  )

  echo "Download URL: $browser_download_url"
  echo "Download to: $release_name"

  http --ignore-stdin -b --timeout 5 -dco "$release_name" "$browser_download_url"

  if [ -f "$release_name" ]; then
    case $release_name in
    *.tar.bz2) tar -xjf "$release_name" ;;
    *.tar.gz) tar -xzf "$release_name" ;;
    *.tar.xz) tar -xzf "$release_name" ;;
    *.bz2) bunzip2 "$release_name" ;;
    *.gz) gunzip "$release_name" ;;
    *.tar) tar -xf "$release_name" ;;
    *.tbz2) tar -xjf "$release_name" ;;
    *.tgz) tar -xzf "$release_name" ;;
    *.zip) unzip -q "$release_name" ;;
    *.Z) uncompress "$release_name" ;;
    *.rar) rar x "$release_name" ;;    # 'rar' must to be installed
    *.jar) jar -xvf "$release_name" ;; # 'jdk' must to be installed
    *) echo "'$release_name' cannot be extracted via extract()" ;;
    esac
  fi

  bin=$(
    find . -type f |
      fzf \
        --query "$executable_query" \
        --select-1 \
        --height=50% \
        --reverse \
        --no-info \
        --prompt="Select the executable: "
  )

  if [[ -n "$bin" ]]; then
    basename=$(basename "$bin")
    if [[ -z "$name" ]]; then
      read -p "Choose an alias (empty to leave: $basename): " name
    fi
    target="$target_bin_dir/${name:-$basename}"
    echo "Installing $bin to $target"
    mv "$bin" "$target" && chmod +x "$target" && echo "[SUCCESS] Saved in: $target"
  else 
    echo "[ERROR] No executable selected"
  fi
  popd >/dev/null || exit 1
else
  case $? in
  2) echo 'Request timed out!' ;;
  3) echo 'Unexpected HTTP 3xx Redirection!' ;;
  4) echo 'HTTP 4xx Client Error!' ;;
  5) echo 'HTTP 5xx Server Error!' ;;
  6) echo 'Exceeded --max-redirects=<n> redirects!' ;;
  *) echo 'Other Error!' ;;
  esac
  exit 1
fi
